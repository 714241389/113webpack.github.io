{"version":3,"file":"index.76b42fb2.js","sources":["../../node_modules/js-event-bus/src/index.js","../../src/helpers/mesh/datachannel/index.ts","../../src/helpers/mesh/webrtc/index.ts","../../node_modules/@solid-primitives/utils/dist/index.js","../../src/helpers/mesh/index.ts","../../src/helpers/mesh/supabase/z85.ts","../../src/helpers/mesh/supabase/index.ts"],"sourcesContent":["(function(caller, bus) {\n  if (typeof exports === 'object' && typeof module === 'object') {\n    module.exports = bus();\n    module.exports.default = module.exports;\n  } else if (typeof exports === 'object') {\n    exports.EventBus = bus();\n  } else {\n    caller.EventBus = bus();\n  }\n})(this, function() {\n  var EventBus = function() {\n    this.listeners = {};\n\n    this.registerListener = function(event, callback, number) {\n      var type = event.constructor.name;\n      number = this.validateNumber(number || 'any');\n\n      if (type !== 'Array') {\n        event = [event];\n      }\n\n      event.forEach(function(e) {\n        if (e.constructor.name !== 'String') {\n          throw new Error(\n            'Only `String` and array of `String` are accepted for the event names!'\n          );\n        }\n\n        that.listeners[e] = that.listeners[e] || [];\n        that.listeners[e].push({\n          callback: callback,\n          number: number,\n        });\n      });\n    };\n\n    // valiodate that the number is a vild number for the number of executions\n    this.validateNumber = function(n) {\n      var type = n.constructor.name;\n\n      if (type === 'Number') {\n        return n;\n      } else if (type === 'String' && n.toLowerCase() === 'any') {\n        return 'any';\n      }\n\n      throw new Error(\n        'Only `Number` and `any` are accepted in the number of possible executions!'\n      );\n    };\n\n    // return wether or not this event needs to be removed\n    this.toBeRemoved = function(info) {\n      var number = info.number;\n      info.execution = info.execution || 0;\n      info.execution++;\n\n      if (number === 'any' || info.execution < number) {\n        return false;\n      }\n\n      return true;\n    };\n\n    var that = this;\n    return {\n      /**\n       * Attach a callback to an event\n       * @param {string} eventName - name of the event.\n       * @param {function} callback - callback executed when this event is triggered\n       */\n      on: function(eventName, callback) {\n        that.registerListener.bind(that)(eventName, callback, 'any');\n      },\n\n      /**\n       * Attach a callback to an event. This callback will not be executed more than once if the event is trigger mutiple times\n       * @param {string} eventName - name of the event.\n       * @param {function} callback - callback executed when this event is triggered\n       */\n      once: function(eventName, callback) {\n        that.registerListener.bind(that)(eventName, callback, 1);\n      },\n\n      /**\n       * Attach a callback to an event. This callback will be executed will not be executed more than the number if the event is trigger mutiple times\n       * @param {number} number - max number of executions\n       * @param {string} eventName - name of the event.\n       * @param {function} callback - callback executed when this event is triggered\n       */\n      exactly: function(number, eventName, callback) {\n        that.registerListener.bind(that)(eventName, callback, number);\n      },\n\n      /**\n       * Kill an event with all it's callbacks\n       * @param {string} eventName - name of the event.\n       */\n      die: function(eventName) {\n        delete that.listeners[eventName];\n      },\n\n      /**\n       * Kill an event with all it's callbacks\n       * @param {string} eventName - name of the event.\n       */\n      off: function(eventName) {\n        this.die(eventName);\n      },\n\n      /**\n       * Remove the callback for the given event\n       * @param {string} eventName - name of the event.\n       * @param {callback} callback - the callback to remove (undefined to remove all of them).\n       */\n      detach: function(eventName, callback) {\n        if (callback === undefined) {\n          that.listeners[eventName] = [];\n          return true;\n        }\n\n        for (var k in that.listeners[eventName]) {\n          if (\n            that.listeners[eventName].hasOwnProperty(k) &&\n            that.listeners[eventName][k].callback === callback\n          ) {\n            that.listeners[eventName].splice(k, 1);\n            return this.detach(eventName, callback);\n          }\n        }\n\n        return true;\n      },\n\n      /**\n       * Remove all the events\n       */\n      detachAll: function() {\n        for (var eventName in that.listeners) {\n          if (that.listeners.hasOwnProperty(eventName)) {\n            this.detach(eventName);\n          }\n        }\n      },\n\n      /**\n       * Emit the event\n       * @param {string} eventName - name of the event.\n       */\n      emit: function(eventName, context) {\n        var listeners = [];\n        for (var name in that.listeners) {\n          if (that.listeners.hasOwnProperty(name)) {\n            if (name === eventName) {\n              //TODO: this lib should definitely use > ES5\n              Array.prototype.push.apply(listeners, that.listeners[name]);\n            }\n\n            if (name.indexOf('*') >= 0) {\n              var newName = name.replace(/\\*\\*/, '([^.]+.?)+');\n              newName = newName.replace(/\\*/g, '[^.]+');\n\n              var match = eventName.match(newName);\n              if (match && eventName === match[0]) {\n                Array.prototype.push.apply(listeners, that.listeners[name]);\n              }\n            }\n          }\n        }\n\n        var parentArgs = arguments;\n\n        context = context || this;\n        listeners.forEach(function(info, index) {\n          var callback = info.callback;\n          var number = info.number;\n\n          if (context) {\n            callback = callback.bind(context);\n          }\n\n          var args = [];\n          Object.keys(parentArgs).map(function(i) {\n            if (i > 1) {\n              args.push(parentArgs[i]);\n            }\n          });\n\n          // this event cannot be fired again, remove from the stack\n          if (that.toBeRemoved(info)) {\n            that.listeners[eventName].splice(index, 1);\n          }\n\n          callback.apply(null, args);\n        });\n      },\n    };\n  };\n\n  return EventBus;\n});\n","import EventBus from \"js-event-bus\";\n\nexport interface FrameFlags {\n    more: boolean,\n    long: boolean,\n}\n\nexport class Frame {\n    buffer: Uint8ClampedArray;\n    \n    static FLAG_MORE = 1;\n    static FLAG_LONG = 1 << 1;\n    static SHORT_MAX_LENGTH = 2 ^ 16 - (1 + 2);\n    static LONG_MAX_LENGTH = 2 ^ 32 - (1 + 4);\n    static SHORT_HEADER_SIZE = 1 + 2;\n    static LONG_HEADER_SIZE = 1 + 4;\n\n    constructor(buffer: Uint8ClampedArray) {\n        this.buffer = buffer;\n    }\n\n    static zero(expected_data_length: number): Frame {\n        const isLongHeader = (expected_data_length > Frame.SHORT_MAX_LENGTH);\n        const totalLength = (isLongHeader ? Frame.LONG_HEADER_SIZE : Frame.SHORT_HEADER_SIZE) + expected_data_length;\n        const buffer = new Uint8ClampedArray(totalLength);\n        const f = new Frame(buffer);\n        f.setFlag(\"long\", isLongHeader);\n        f.length = expected_data_length;\n        return f;\n    }\n\n    getFlags(): FrameFlags {\n        const flags = this.buffer.at(0) as number;\n        return {\n            more: (flags & Frame.FLAG_MORE) > 0,\n            long: (flags & Frame.FLAG_LONG) > 0,\n        };\n    }\n\n    setFlag<K extends keyof FrameFlags>(key: K, value: boolean): FrameFlags {\n        const oldFlags = this.buffer.at(0) as number;\n        if (key === \"more\") {\n            this.buffer[0] = value ? (oldFlags | Frame.FLAG_MORE) : (oldFlags & (~Frame.FLAG_MORE));\n        } else if (key === \"long\") {\n            this.buffer[0] = value ? (oldFlags | Frame.FLAG_LONG) : (oldFlags & (~Frame.FLAG_LONG));\n        }\n        return this.getFlags();\n    }\n    \n    /**\n     * Get the payload's length if it's valid.\n     */\n    validateLength(): number | null {\n        if (this.byteLength > 1) {\n            const headerSize = this.getFlags().long? Frame.LONG_HEADER_SIZE: Frame.SHORT_HEADER_SIZE;\n            if (this.byteLength >= headerSize) {\n                if (this.byteLength >= (headerSize + this.length)) {\n                    return this.length;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Get the length attribute (the length of payload) from header.\n     * For the total size of the frame, see `byteLength`; for verified length, see `validateLength`.\n     */\n    get length(): number {\n        if (this.getFlags().long) {\n            const view = new DataView(this.buffer.buffer, 1 + this.buffer.byteOffset, 4);\n            return view.getUint32(0);\n        } else {\n            const view = new DataView(this.buffer.buffer, 1 + this.buffer.byteOffset, 2);\n            return view.getUint16(0);\n        }\n    }\n\n    /**\n     * Set the length attribute (the length of payload) in the header.\n     */\n    set length(len: number) {\n        if (this.getFlags().long) {\n            new DataView(this.buffer.buffer, 1 + this.buffer.byteOffset, 4).setInt32(0, len);\n        } else {\n            new DataView(this.buffer.buffer, 1 + this.buffer.byteOffset, 2).setInt16(0, len);\n        }\n    }\n\n    /**\n     *  Get the total length of the header and payload.\n     */\n    get byteLength(): number {\n        return this.buffer.length;\n    }\n\n    /**\n     * Get the payload as a subarray.\n     * \n     * WARNING: The length must be valid when using this method.\n     */\n    data(): Uint8ClampedArray {\n        if (this.getFlags().long) {\n            return this.buffer.subarray(Frame.LONG_HEADER_SIZE, Frame.LONG_HEADER_SIZE+this.length);\n        } else {\n            return this.buffer.subarray(Frame.SHORT_HEADER_SIZE, Frame.SHORT_HEADER_SIZE+this.length);\n        }\n    }\n\n    /**\n     * Get the payload as a `DataView`.\n     * @param expected_length the length you expected, it will be set to the length of the data if it is larger than the length.\n     */\n    dataView(expected_length?: number): DataView {\n        const length = typeof expected_length !== \"undefined\" ? Math.min(expected_length, this.length) : this.length;\n        const headerSize = this.headerLength;\n        return new DataView(this.buffer.buffer, headerSize + this.buffer.byteOffset, length);\n    }\n\n    static fromArray(array: Uint8Array, more?: boolean): Frame {\n        const f = Frame.zero(array.length);\n        const data = f.data();\n        data.set(array);\n        f.setFlag(\"more\", more || false);\n        return f;\n    }\n\n    static fromString(s: string, more?: boolean): Frame {\n        const encoder = new TextEncoder();\n        const result = encoder.encode(s);\n        return this.fromArray(result, more);\n    }\n\n    toString(): string {\n        const decoder = new TextDecoder(\"utf-8\");\n        return decoder.decode(this.data());\n    }\n\n    static fromUInt(int: number, more?: boolean): Frame {\n        const buffer = new Uint8Array(4);\n        new DataView(buffer.buffer).setUint32(0, int);\n        return Frame.fromArray(buffer, more);\n    }\n\n    toUInt(): number {\n        return this.dataView().getUint32(0);\n    }\n\n    isUInt(): boolean {\n        return this.length === 4;\n    }\n\n    static fromBigUInt(int: bigint, more?: boolean): Frame {\n        const buffer = new Uint8Array(8);\n        new DataView(buffer.buffer).setBigUint64(0, int);\n        return Frame.fromArray(buffer, more);\n    }\n\n    toBigUInt(): bigint {\n        return this.dataView().getBigUint64(0);\n    }\n\n    isBigUInt(): boolean {\n        return this.length === 8;\n    }\n\n    /// Packing frames.\n    static pack(...frames: Frame[]): Uint8Array {\n        const length = frames.map((v) => v.byteLength).reduce((prev, curr) => prev + curr, 0);\n        const bundle = new Uint8Array(length);\n        let offest = 0;\n        for (const f of frames) {\n            bundle.set(f.buffer, offest);\n            offest += f.byteLength;\n        }\n        return bundle;\n    }\n\n    /**\n     * Read the header of the `Uint8Array`.\n     * @param array the array to read.\n     * @returns the flags of header and the length of payload.\n     */\n    static readHeader(array: Uint8ClampedArray): [FrameFlags, number] | null {\n        if (array.length === 0) return null;\n        const flags = array[0];\n        const more = (flags & this.FLAG_MORE) > 0;\n        const long = (flags & this.FLAG_LONG) > 0;\n        const headerSize = (long? this.LONG_HEADER_SIZE: this.SHORT_HEADER_SIZE);\n        if (array.length < headerSize) return null;\n        const lengthSize = headerSize - 1;\n        const buffer = new Uint8Array(lengthSize);\n        buffer.set(array.subarray(1, headerSize), 0);\n        const lengthView = new DataView(buffer.buffer, 0, lengthSize);\n        const flagsObject = <FrameFlags>{\n            more, long\n        };\n        const length = long? lengthView.getUint32(0): lengthView.getUint16(0);\n        return [flagsObject, length];\n    }\n\n    /**\n     * Unpack an `Uint8Array`.\n     * @param array the array to unpack.\n     * @returns the frames read, the rest data and the length required for next frame.\n     */\n    static unpack(array: Uint8ClampedArray): [Frame[], Uint8ClampedArray, number] {\n        let rest = array;\n        const frames: Frame[] = [];\n        while (rest.length > 0) {\n            const headerResult = this.readHeader(rest);\n            if (headerResult) {\n                const [flags, length] = headerResult;\n                const headerSize = flags.long? this.LONG_HEADER_SIZE: this.SHORT_HEADER_SIZE;\n                if (rest.length >= (length + headerSize)) {\n                    frames.push(new Frame(rest.subarray(0, headerSize + length)));\n                    rest = rest.subarray(headerSize + length);\n                    if (!flags.more) break;\n                } else {\n                    return [frames, rest, (length + headerSize) - rest.length];\n                }\n            } else {\n                rest = new Uint8ClampedArray(0);\n            }\n        }\n        return [frames, rest, 0];\n    }\n\n    /**\n     * Get current header length.\n     */\n    get headerLength(): number {\n        return this.getFlags().long? Frame.LONG_HEADER_SIZE: Frame.SHORT_HEADER_SIZE;\n    }\n\n    /**\n     * Get current padding size.\n     */\n    get paddingLength(): number {\n        return this.byteLength - this.headerLength - this.length;\n    }\n\n    /**\n     * Get a clone of this frame.\n     * @param padding the padding the clone will contain.\n     * @returns a new frame.\n     */\n    clone(padding?: number): Frame {\n        const array = new Uint8ClampedArray(this.headerLength + this.length + (padding || 0));\n        array.set(this.buffer.slice(0, this.headerLength + this.length));\n        return new Frame(array);\n    }\n}\n\nexport interface Message {\n    dstUserDeviceId: string,\n    roomId: string,\n    srcUserDeviceId: string,\n    message: Frame[],\n}\n\nexport interface DataChannel {\n    send(message: Message) : Promise<void>;\n    close(): Promise<void> | void;\n\n    get bus(): EventBus;\n}\n","import EventBus from \"js-event-bus\";\nimport { DataChannel, Frame, Message } from \"../datachannel\";\n\n\nconst toArrayBuffer = (data: string | ArrayBuffer | Blob): Promise<ArrayBuffer> => {\n    if (typeof data !== \"string\") {\n        if (typeof (data as Blob).arrayBuffer !== \"undefined\") {\n            return (data as Blob).arrayBuffer();\n        } else {\n            return Promise.resolve(data as ArrayBuffer);\n        }\n    } else {\n        const encoder = new TextEncoder();\n        return Promise.resolve(encoder.encode(data));\n    }\n};\n\nexport class WebRTCDatachannel implements DataChannel {\n    bus: EventBus;\n    rtcDataChan: RTCDataChannel;\n\n    constructor(rtcDataChan: RTCDataChannel) {\n        this.bus = new EventBus();\n        this.rtcDataChan = rtcDataChan;\n        const onRemoteData = async (ev: MessageEvent<ArrayBuffer | Blob | string>) => this.onRemoteData(ev);\n        this.rtcDataChan.addEventListener(\"open\", () => {\n            this.bus.emit<WebRTCDatachannel>(\"open\", this);\n            this.rtcDataChan.addEventListener(\"message\", onRemoteData);\n        });\n        this.rtcDataChan.addEventListener(\"close\", () => {\n            this.rtcDataChan.removeEventListener(\"message\", onRemoteData);\n            this.bus.emit<WebRTCDatachannel>(\"close\", this);\n        });\n    }\n\n    async send(message: Message): Promise<void> {\n        const frames = [Frame.fromString(message.dstUserDeviceId, true), Frame.fromString(message.roomId, true), Frame.fromString(message.srcUserDeviceId, true), ...message.message];\n        this.rtcDataChan.send(Frame.pack(...frames));\n    }\n\n    async onRemoteData(ev: MessageEvent<Blob | ArrayBuffer | string>) {\n        const data = await toArrayBuffer(ev.data);\n        const [frames,] = Frame.unpack(new Uint8ClampedArray(data));\n        const [dstId, roomId, srcId, ...payload] = frames;\n        const message: Message = {\n            dstUserDeviceId: dstId.toString(),\n            roomId: roomId.toString(),\n            srcUserDeviceId: srcId.toString(),\n            message: payload,\n        };\n        this.bus.emit(\"data\", this, message);\n    }\n\n    close() {\n        this.rtcDataChan.close();\n    }\n}\n","var __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\n\n// src/index.ts\nimport { getOwner, onCleanup, createSignal, DEV, untrack, batch } from \"solid-js\";\nimport { isServer as _isServer } from \"solid-js/web\";\nvar noop = () => void 0;\nvar isServer = _isServer;\nvar isClient = !isServer;\nvar isDev = DEV && isClient;\nvar isProd = !isDev;\nvar warn = (...a) => isDev && console.warn(...a);\nvar ofClass = (v, c) => v instanceof c || v && v.constructor === c;\nfunction isObject(value) {\n  return value !== null && (typeof value === \"object\" || typeof value === \"function\");\n}\nvar compare = (a, b) => a < b ? -1 : a > b ? 1 : 0;\nfunction chain(callbacks) {\n  return (...args) => {\n    for (const callback of callbacks) {\n      if (typeof callback === \"function\")\n        callback(...args);\n    }\n  };\n}\nvar clamp = (n, min, max) => Math.min(Math.max(n, min), max);\nvar access = (v) => typeof v === \"function\" && !v.length ? v() : v;\nvar asArray = (value) => Array.isArray(value) ? value : [value];\nvar accessArray = (list) => list.map((v) => access(v));\nvar withAccess = (value, fn) => {\n  const _value = access(value);\n  typeof _value !== \"undefined\" && _value !== null && fn(_value);\n};\nvar asAccessor = (v) => typeof v === \"function\" ? v : () => v;\nfunction accessWith(valueOrFn, ...args) {\n  return typeof valueOrFn === \"function\" ? valueOrFn(...args) : valueOrFn;\n}\nfunction forEachEntry(object, iterator) {\n  Object.entries(object).forEach(([key, item], index, pairs) => iterator(key, item, index, pairs, object));\n}\nvar entries = Object.entries;\nvar keys = Object.keys;\nvar promiseTimeout = (ms, throwOnTimeout = false, reason = \"Timeout\") => new Promise((resolve, reject) => throwOnTimeout ? setTimeout(() => reject(reason), ms) : setTimeout(resolve, ms));\nfunction raceTimeout(input, ms, throwOnTimeout = false, reason = \"Timeout\") {\n  const promises = asArray(input);\n  const race = Promise.race([...promises, promiseTimeout(ms, throwOnTimeout, reason)]);\n  race.finally(() => {\n    promises.forEach((p) => p && typeof p === \"object\" && typeof p.dispose === \"function\" && p.dispose());\n  });\n  return race;\n}\nvar onRootCleanup = (fn) => getOwner() ? onCleanup(fn) : fn;\nvar createCallbackStack = () => {\n  let stack = [];\n  const clear = () => stack = [];\n  return {\n    push: (...callbacks) => stack.push(...callbacks),\n    execute(arg0, arg1, arg2, arg3) {\n      stack.forEach((cb) => cb(arg0, arg1, arg2, arg3));\n      clear();\n    },\n    clear\n  };\n};\nfunction createMicrotask(fn) {\n  let calls = 0;\n  let args;\n  return (...a) => {\n    args = a, calls++;\n    queueMicrotask(() => --calls === 0 && fn(...args));\n  };\n}\nfunction createProxy(traps) {\n  return new Proxy({}, {\n    get: (_, k) => traps.get(k),\n    set: (_, k, v) => {\n      var _a;\n      (_a = traps.set) == null ? void 0 : _a.call(traps, k, v);\n      return false;\n    }\n  });\n}\nfunction createTrigger(options) {\n  return createSignal(void 0, { equals: false, name: options == null ? void 0 : options.name });\n}\nfunction createTriggerCache(options) {\n  const cache = /* @__PURE__ */ new Map();\n  return {\n    dirty: (key) => {\n      var _a;\n      return (_a = cache.get(key)) == null ? void 0 : _a[1]();\n    },\n    dirtyAll: () => cache.forEach((s) => s[1]()),\n    track(key) {\n      let trigger = cache.get(key);\n      if (!trigger) {\n        trigger = createTrigger(options);\n        cache.set(key, trigger);\n      }\n      trigger[0]();\n    }\n  };\n}\nfunction createStaticStore(init) {\n  const copy = __spreadValues({}, init);\n  const store = {};\n  const cache = /* @__PURE__ */ new Map();\n  const getValue = (key) => {\n    const saved = cache.get(key);\n    if (saved)\n      return saved[0]();\n    const signal = createSignal(copy[key], {\n      name: typeof key === \"string\" ? key : void 0\n    });\n    cache.set(key, signal);\n    delete copy[key];\n    return signal[0]();\n  };\n  const setValue = (key, value) => {\n    const saved = cache.get(key);\n    if (saved)\n      return saved[1](value);\n    if (key in copy)\n      copy[key] = accessWith(value, [copy[key]]);\n  };\n  for (const key of keys(init)) {\n    store[key] = void 0;\n    Object.defineProperty(store, key, {\n      get: getValue.bind(void 0, key)\n    });\n  }\n  const setter = (a, b) => {\n    if (isObject(a))\n      untrack(() => {\n        batch(() => {\n          for (const [key, value] of entries(accessWith(a, store)))\n            setValue(key, () => value);\n        });\n      });\n    else\n      setValue(a, b);\n    return store;\n  };\n  return [store, setter];\n}\nexport {\n  access,\n  accessArray,\n  accessWith,\n  asAccessor,\n  asArray,\n  chain,\n  clamp,\n  compare,\n  createCallbackStack,\n  createMicrotask,\n  createProxy,\n  createStaticStore,\n  createTrigger,\n  createTriggerCache,\n  entries,\n  forEachEntry,\n  isClient,\n  isDev,\n  isObject,\n  isProd,\n  isServer,\n  keys,\n  noop,\n  ofClass,\n  onRootCleanup,\n  promiseTimeout,\n  raceTimeout,\n  warn,\n  withAccess\n};\n","// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport adapter from \"webrtc-adapter\";\nimport EventBus from \"js-event-bus\";\nimport { broadcastId } from \"../getDeviceId\";\nimport { DataChannel, Frame, Message } from \"./datachannel\";\nimport { WebRTCDatachannel } from \"./webrtc\";\nimport { promiseTimeout } from \"@solid-primitives/utils\";\nimport {validate as uuidValidate} from \"uuid\";\n\nconst PROTO_TYPE_SYNC_PEERS = 1;\nconst PROTO_TYPE_RTC_PROVIDE_OFFER = 2;\nconst PROTO_TYPE_SYNC_PEERS_REP = 3;\nconst PROTO_TYPE_RTC_ICE_CANDIDATE = 4;\nconst PROTO_TYPE_MAX_NUM = 255;\nconst DATACHANNEL_LABEL = \"magicmesh\";\nconst DATACHANNEL_ID = 64;\n\nconst RTCPEERCONNECTION_OPTIONS: RTCConfiguration = {\n    iceServers: [\n        {\n            urls: \"stun:stun.stunprotocol.org\",\n        },\n    ]\n};\n\nexport enum PeerConnectionState {\n    connecting = \"connecting\",\n    connected = \"connected\",\n    disconnected = \"disconnected\",\n    closed = \"closed\",\n    failed = \"failed\",\n    unknown = \"unknown\",\n}\n\nexport class Peer {\n    userDeviceId: string;\n    connection: RTCPeerConnection;\n    clk: bigint;\n    datachannel: WebRTCDatachannel;\n    connectionState: PeerConnectionState;\n    bus: EventBus;\n    makingOffer: boolean;\n\n    constructor(userDeviceId: string, clk: bigint) {\n        this.userDeviceId = userDeviceId;\n        this.connection = new RTCPeerConnection(RTCPEERCONNECTION_OPTIONS);\n        this.clk = clk;\n        this.datachannel = new WebRTCDatachannel(\n            this.connection.createDataChannel(\n                DATACHANNEL_LABEL, {\n                    protocol: \"magicmesh-rtc0\",\n                    id: DATACHANNEL_ID,\n                    negotiated: true\n                }\n            )\n        );\n        this.connectionState = PeerConnectionState.unknown;\n        this.bus = new EventBus();\n        this.makingOffer = false;\n        this.setupConnectionState();\n        this.connection.addEventListener(\"negotiationneeded\", () => this.bus.emit(\"negotiationneeded\", undefined, this));\n        this.connection.addEventListener(\"icecandidate\", (ev) => this.bus.emit(\"icecandidate\", undefined, this, ev));\n        this.connection.addEventListener(\"iceconnectionstatechange\", () => {\n            if (this.connection.iceConnectionState === \"failed\") {\n                this.connection.restartIce();\n            }\n        });\n    }\n\n    setupConnectionState() {\n        if (typeof this.connection.connectionState !== \"undefined\") { // Firefox does not support connectionState and connectionstatechange\n            this.connection.addEventListener(\"connectionstatechange\", () => {\n                switch (this.connection.connectionState) {\n                case \"new\":\n                case \"connecting\":\n                    this.connectionState = PeerConnectionState.connecting;\n                    break;\n                case \"closed\":\n                    this.connectionState = PeerConnectionState.closed;\n                    break;\n                case \"connected\":\n                    this.connectionState = PeerConnectionState.connected;\n                    break;\n                case \"disconnected\":\n                    this.connectionState = PeerConnectionState.disconnected;\n                    break;\n                case \"failed\":\n                    this.connectionState = PeerConnectionState.failed;\n                    break;\n                default:\n                    this.connectionState = PeerConnectionState.unknown;\n                    break;\n                }\n                this.bus.emit(\"connectionstatechange\", this, this.connectionState);\n            });\n        } else {\n            this.connection.addEventListener(\"iceconnectionstatechange\", () => {\n                const state = this.connection.iceConnectionState;\n                if (state === \"new\" || state === \"checking\" || state === \"completed\") {\n                    this.connectionState = PeerConnectionState.connecting;\n                } else if (state === \"connected\") {\n                    this.connectionState = PeerConnectionState.connected;\n                } else if (state === \"disconnected\") {\n                    this.connectionState = PeerConnectionState.disconnected;\n                } else if (state === \"closed\") {\n                    this.connectionState = PeerConnectionState.closed;\n                } else if (state === \"failed\") {\n                    this.connectionState = PeerConnectionState.failed;\n                } else {\n                    this.connectionState = PeerConnectionState.unknown;\n                }\n                this.bus.emit(\"connectionstatechange\", this, this.connectionState);\n            });\n        }\n    }\n\n    isConnectionAvaliable(): boolean {\n        if (this.connectionState === \"connected\") {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    async send(roomId: string, srcUserDeviceId: string, frames: Frame[]) {\n        await this.datachannel.send({\n            roomId: roomId,\n            srcUserDeviceId: srcUserDeviceId,\n            dstUserDeviceId: this.userDeviceId,\n            message: frames,\n        });\n    }\n\n    disconnect() {\n        this.datachannel.close();\n        this.connection.close();\n    }\n}\n\nexport class Router {\n    peers: Peer[];\n    alterChan: DataChannel;\n    clk: bigint;\n    userDeviceId: string;\n    bus: EventBus;\n    onMessageCallback: ((msg: Message) => void);\n    onNegotiate: ((peer: Peer) => void);\n    onIceCandidate: ((peer: Peer, ev: RTCPeerConnectionIceEvent) => void);\n    roomId: string;\n\n    constructor(userDeviceId: string, alterChan: DataChannel, roomId: string) {\n        this.peers = [];\n        this.alterChan = alterChan;\n        this.clk = BigInt(0);\n        this.userDeviceId = userDeviceId;\n        this.bus = new EventBus();\n        this.roomId = roomId;\n        this.onMessageCallback = (msg) => {\n            if (msg.dstUserDeviceId === this.userDeviceId || msg.dstUserDeviceId === broadcastId) {\n                if (msg.message[0].isUInt() && msg.message[0].toUInt() <= PROTO_TYPE_MAX_NUM && msg.message[1].isBigUInt()) {\n                    this.handleProtocolMessage(msg);\n                } else {\n                    this.bus.emit(\"data\", this, msg);\n                }\n            }\n        };\n        this.onNegotiate = (peer) => {\n            peer.makingOffer = true;\n            peer.connection.setLocalDescription()\n                .then(() => {\n                    const offer = peer.connection.localDescription;\n                    if (offer) {\n                        const {sdp, type} = offer;\n                        return this.provideRTCOffer(peer.userDeviceId, {sdp, type});\n                    }\n                })\n                .finally(() => peer.makingOffer = false);\n        };\n        this.onIceCandidate = (peer, ev) => {\n            if (ev.candidate) {\n                this.sendRTCIceCandidate(peer.userDeviceId, ev.candidate);\n            }\n        };\n        alterChan.bus.on(\"data\", this.onMessageCallback);\n    }\n\n    async broadcast(frames: Frame[], noAlternativeChannel?: boolean) {\n        const sendingPromises: Promise<void>[] = [];\n        for (const peer of this.peers) {\n            if (peer.isConnectionAvaliable()) {\n                sendingPromises.push(peer.send(this.roomId, this.userDeviceId, frames));\n            }\n        }\n        if (!noAlternativeChannel && sendingPromises.length === 0) {\n            await this.sendToAlternativeChannel(broadcastId, frames);\n        } else {\n            await Promise.all(sendingPromises);\n        }\n    }\n\n    findPeerById(userDeviceId: string): Peer | null {\n        for (const peer of this.peers) {\n            if (peer.userDeviceId === userDeviceId) {\n                return peer;\n            }\n        }\n        return null;\n    }\n\n    loopbackSend(dstUserDeviceId: string, frames: Frame[]) {\n        this.bus.emit(\"data\", this, <Message>{\n            srcUserDeviceId: this.userDeviceId,\n            dstUserDeviceId: dstUserDeviceId,\n            message: frames,\n            roomId: this.roomId,\n        });\n    }\n\n    async send(dstUserDeviceId: string, frames: Frame[]) {\n        if (dstUserDeviceId === this.userDeviceId) {\n            this.loopbackSend(dstUserDeviceId, frames);\n            return;\n        }\n        const peer = this.findPeerById(dstUserDeviceId);\n        if (peer) {\n            if (peer.isConnectionAvaliable()) {\n                await peer.send(this.roomId, this.userDeviceId, frames);\n            } else {\n                await this.sendToAlternativeChannel(dstUserDeviceId, frames);\n            }\n        }\n    }\n\n    async broadcastPeerList(customPeerIdList?: string[], isReply?: boolean) {\n        const peerIdList = customPeerIdList || [this.userDeviceId, ...this.peers.map(p => p.userDeviceId)];\n        const frames = this.buildProtocolMessage(isReply ? PROTO_TYPE_SYNC_PEERS_REP : PROTO_TYPE_SYNC_PEERS, peerIdList);\n        await this.broadcast(frames);\n    }\n\n    async sendToAlternativeChannel(dstUserDeviceId: string, frames: Frame[]) {\n        await this.alterChan.send({\n            srcUserDeviceId: this.userDeviceId,\n            dstUserDeviceId: dstUserDeviceId,\n            roomId: this.roomId,\n            message: frames,\n        });\n    }\n\n    addPeer(peer: Peer) {\n        peer.datachannel.bus.on(\"data\", this.onMessageCallback);\n        peer.bus.on(\"negotiationneeded\", this.onNegotiate);\n        peer.bus.on(\"icecandidate\", this.onIceCandidate);\n        this.peers.push(peer);\n        this.bus.emit(\"addpeer\", this, peer);\n    }\n\n    removePeer(peer: Peer) {\n        const index = this.peers.indexOf(peer);\n        this.peers.splice(index, 1);\n        peer.datachannel.bus.detach(\"data\", this.onMessageCallback);\n        peer.bus.detach(\"negotiationneeded\", this.onNegotiate);\n        peer.bus.detach(\"icecandidate\", this.onIceCandidate);\n        this.bus.emit(\"removepeer\", this, peer);\n    }\n\n    async onSyncPeerMessage(message: Message) {\n        const code = message.message[0].toUInt();\n        const receivedPeerList = JSON.parse(message.message[2].toString()) as unknown; // JSON\n        const remotePeerList = Array.isArray(receivedPeerList) ? receivedPeerList.filter(v => typeof v === \"string\" && uuidValidate(v)) : [];\n        remotePeerList.filter(id => this.findPeerById(id) == null).forEach(id => {\n            const peer = new Peer(id, BigInt(0));\n            this.addPeer(peer);\n        }); // add all unknown peers\n        if (code === PROTO_TYPE_SYNC_PEERS) {\n            const waitingTime = Math.random() * 2000;\n            await promiseTimeout(waitingTime); // wait random seconds to avoid network flood\n            const remoteUnknownPeerIds = this.peers.map(p => p.userDeviceId).filter(id => !remotePeerList.includes(id));\n            if (!remotePeerList.includes(this.userDeviceId)) {\n                remoteUnknownPeerIds.push(this.userDeviceId);\n            }\n            if (remoteUnknownPeerIds.length > 0) {\n                await this.broadcastPeerList(remoteUnknownPeerIds, true);\n            }\n        }\n    }\n\n    handleProtocolMessage(message: Message) {\n        if (message.srcUserDeviceId === this.userDeviceId) {\n            return;\n        }\n        const msgTypeCode = message.message[0].toUInt();\n        const clkUpdate = message.message[1].toBigUInt();\n        let peer = this.findPeerById(message.srcUserDeviceId);\n        if (!peer) {\n            peer = new Peer(message.srcUserDeviceId, clkUpdate);\n            this.addPeer(peer);\n        } else {\n            if (peer.clk >= clkUpdate) return;\n        }\n        if (msgTypeCode === PROTO_TYPE_SYNC_PEERS || msgTypeCode === PROTO_TYPE_SYNC_PEERS_REP) {\n            this.onSyncPeerMessage(message).catch((reason) => console.error(reason));\n        } else if (msgTypeCode === PROTO_TYPE_RTC_PROVIDE_OFFER) {\n            this.onProvideRTCOfferMessage(message).catch(reason => console.error(reason));\n        } else if (msgTypeCode === PROTO_TYPE_RTC_ICE_CANDIDATE) {\n            this.onRTCIceCandidateMessage(message).catch(reason => console.error(reason));\n        } else {\n            console.error(\"unknown message type #%d\", msgTypeCode);\n        }\n    }\n\n    tick() {\n        return this.clk++;\n    }\n\n    buildProtocolMessage(msgType: number, obj: unknown): Frame[] {\n        return [Frame.fromUInt(msgType, true), Frame.fromBigUInt(this.tick(), true), Frame.fromString(JSON.stringify(obj), false)];\n    }\n\n    async stop(): Promise<void> {\n        const closePromise = this.alterChan.close();\n        if (typeof closePromise !== \"undefined\") {\n            await closePromise;\n        }\n        for (const peer of this.peers) {\n            peer.disconnect();\n        }\n        for (let i=0; i<this.peers.length; i++) {\n            this.peers.pop();\n        }\n        this.bus.emit(\"stopped\", this);\n        this.bus.detachAll();\n    }\n\n    async provideRTCOffer(dstUserDevId: string, offer: RTCSessionDescriptionInit) {\n        this.send(dstUserDevId, this.buildProtocolMessage(\n            PROTO_TYPE_RTC_PROVIDE_OFFER,\n            offer,\n        ));\n    }\n\n    async onProvideRTCOfferMessage(message: Message) {\n        const offer = JSON.parse(message.message[2].toString()) as unknown;\n        if (offer && typeof offer === \"object\") {\n            if ((offer as {[key: string]: unknown})[\"type\"]) { // Guess it is an RTCSessionDesscriptionInit\n                const peer = this.findPeerById(message.srcUserDeviceId);\n                const offerTyped = offer as RTCSessionDescriptionInit;\n                if (peer) {\n                    await peer.connection.setRemoteDescription(offerTyped);\n                    if (offerTyped.type === \"offer\") {\n                        await peer.connection.setLocalDescription();\n                        const description = peer.connection.localDescription;\n                        if (description) {\n                            await this.provideRTCOffer(message.srcUserDeviceId, description);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    async sendRTCIceCandidate(dstUsrDevId: string, candidate: RTCIceCandidate) {\n        await this.send(dstUsrDevId, this.buildProtocolMessage(\n            PROTO_TYPE_RTC_ICE_CANDIDATE,\n            candidate.toJSON(),\n        ));\n    }\n\n    async onRTCIceCandidateMessage(message: Message) {\n        const candidate = JSON.parse(message.message[2].toString()) as unknown;\n        if (candidate && typeof candidate === \"object\" && (candidate as {[key: string]: unknown})[\"candidate\"]) {\n            const candidateTyped = candidate as RTCIceCandidateInit;\n            const peer = this.findPeerById(message.srcUserDeviceId);\n            if (peer && peer.connection.remoteDescription) {\n                peer.connection.addIceCandidate(candidateTyped);\n            }\n        }\n    }\n}\n","// Ported from https://github.com/msealand/z85.node/blob/master/index.js\nconst encoder = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-:+=^!/*?&<>()[]{}@%$#\".split(\"\");\n\nconst decoder = [\n    0x00, 0x44, 0x00, 0x54, 0x53, 0x52, 0x48, 0x00, \n    0x4B, 0x4C, 0x46, 0x41, 0x00, 0x3F, 0x3E, 0x45, \n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, \n    0x08, 0x09, 0x40, 0x00, 0x49, 0x42, 0x4A, 0x47, \n    0x51, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, \n    0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, \n    0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, \n    0x3B, 0x3C, 0x3D, 0x4D, 0x00, 0x4E, 0x43, 0x00, \n    0x00, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, \n    0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, \n    0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, \n    0x21, 0x22, 0x23, 0x4F, 0x00, 0x50, 0x00, 0x00\n];\n\nexport const encode = (data: Uint8Array | Uint8ClampedArray): string => {\n    if ((data.length % 4) !== 0) {\n        throw Error(\"data's length must be divisible by 4\");\n    }\n\n    const size = data.length;\n    let str = \"\",\n        byte_nbr = 0,\n        value = 0;\n    while (byte_nbr < size) {\n        const characterCode = data[byte_nbr++];\n        value = (value * 256) + characterCode;\n        if ((byte_nbr % 4) === 0) {\n            let divisor = 85 * 85 * 85 * 85;\n            while (divisor >= 1) {\n                const idx = Math.floor(value / divisor) % 85;\n                str += encoder[idx];\n                divisor /= 85;\n            }\n            value = 0;\n        }\n    }\n\n    return str;\n};\n\nexport const decode = (s: string) => {\n    if ((s.length % 5) !== 0) {\n        throw Error(\"string's length must be divisible by 5\");\n    }\n\n    const dest = new Uint8ClampedArray(s.length * 4 / 5),\n        string_len = s.length;\n    let byte_nbr = 0,\n        char_nbr = 0,\n        value = 0;\n    while (char_nbr < string_len) {\n        const idx = s.charCodeAt(char_nbr++) - 32;\n        if ((idx < 0) || (idx >= decoder.length)) {\n            return;\n        }\n        value = (value * 85) + decoder[idx];\n        if ((char_nbr % 5) === 0) {\n            let divisor = 256 * 256 * 256;\n            while (divisor >= 1) {\n                dest[byte_nbr++] = (value / divisor) % 256;\n                divisor /= 256;\n            }\n            value = 0;\n        }\n    }\n\n    return dest;\n};\n\nexport default {\n    encode, decode\n};\n","import { RealtimeChannel, SupabaseClient } from \"@supabase/supabase-js\";\nimport { DataChannel, Frame, Message } from \"../datachannel\";\nimport EventBus from \"js-event-bus\";\nimport { broadcastId } from \"../../getDeviceId\";\nimport z85 from \"./z85\";\n\ninterface MessagePushPayload {\n    room: string,\n    dst_user_dev_id: string,\n    src_user_dev_id: string,\n    message: string[]\n    id: number,\n    created_at: string,\n}\n\ninterface MessagePush {\n    columns: ({type: string, name: string})[],\n    commit_timestamp: string,\n    errors: unknown | null,\n    type: string,\n    record: MessagePushPayload,\n    schema: string,\n    table: string,\n}\n\nexport class SupabaseDatachannel implements DataChannel {\n    rtDbChannel: RealtimeChannel;\n    rtDbBroadcastChan: RealtimeChannel;\n    supabase: SupabaseClient;\n    bus: EventBus;\n    roomId: string;\n\n    constructor(rtDbChannel: RealtimeChannel, rtDbBroadcastChan: RealtimeChannel, supabase: SupabaseClient, roomId: string) {\n        this.rtDbChannel = rtDbChannel;\n        this.rtDbBroadcastChan = rtDbBroadcastChan;\n        this.supabase = supabase;\n        this.bus = new EventBus();\n        this.rtDbChannel.on(\"INSERT\", undefined, (ev: MessagePush) => this.onRemoteMessage(ev));\n        this.rtDbBroadcastChan.on(\"INSERT\", undefined, (ev: MessagePush) => this.onRemoteMessage(ev));\n        this.rtDbChannel.onClose(() => this.onAnyChannelClose());\n        this.rtDbBroadcastChan.onClose(() => this.onAnyChannelClose());\n        this.roomId = roomId;\n        if (!(this.rtDbChannel.isJoined() || this.rtDbChannel.isJoining())) {\n            this.rtDbChannel.subscribe();\n        }\n        if (!(this.rtDbBroadcastChan.isJoined() || this.rtDbBroadcastChan.isJoining())) {\n            this.rtDbBroadcastChan.subscribe();\n        }\n    }\n\n    static ofRoom(supabase: SupabaseClient, roomId: string, myUserDeviceId: string) {\n        const rtChan = supabase.channel(`realtime:public:room_message_queue:dst_user_dev_id=eq.${myUserDeviceId}`, {selfBroadcast: true});\n        const rtBroadcast = supabase.channel(`realtime:public:room_message_queue:dst_user_dev_id=eq.${broadcastId}`, {selfBroadcast: false});\n        return new SupabaseDatachannel(rtChan, rtBroadcast, supabase, roomId);\n    }\n\n    async send(message: Message): Promise<void> {\n        const {error} = await this.supabase.from(\"room_message_queue\").insert({\n            room: message.roomId,\n            dst_user_dev_id: message.dstUserDeviceId,\n            src_user_dev_id: message.srcUserDeviceId,\n            message: message.message.map((f) => {\n                if ((f.byteLength % 4) !== 0) {\n                    const padding = 4 - (f.byteLength % 4);\n                    return z85.encode(f.clone(padding).buffer);\n                } else {\n                    return z85.encode(f.buffer);\n                }\n            }),\n        });\n        if (error) {\n            throw error;\n        }\n    }\n\n    onAnyChannelClose() {\n        this.close();\n        if (this.rtDbBroadcastChan.isClosed() && this.rtDbChannel.isClosed()) {\n            this.bus.emit(\"close\", this);\n        }\n    }\n\n    onRemoteMessage(push: MessagePush): void {\n        if (push.errors) {\n            return;\n        }\n        let allFramesDecodedMark = true;\n        const payload = push.record;\n        const message: Message = {\n            roomId: payload.room,\n            dstUserDeviceId: payload.dst_user_dev_id,\n            srcUserDeviceId: payload.src_user_dev_id,\n            message: payload.message.map((s) => {\n                if ((s.length % 5) !== 0) { // Invalid z85 data\n                    allFramesDecodedMark = false;\n                    return Frame.zero(0);\n                }\n                const decodedBuf = z85.decode(s); \n                if (decodedBuf) {\n                    return new Frame(decodedBuf);\n                } else {\n                    allFramesDecodedMark = false;\n                    return Frame.zero(0);\n                }\n            })\n        };\n        if (allFramesDecodedMark) {\n            this.bus.emit<SupabaseDatachannel>(\"data\", this, message);\n        }\n    }\n\n    close() {\n        if (!this.rtDbChannel.isClosed()) {\n            this.rtDbChannel.unsubscribe();\n        }\n        if (!this.rtDbBroadcastChan.isClosed()) this.rtDbBroadcastChan.unsubscribe();\n    }\n}\n"],"names":["this","Frame","constructor","buffer","zero","expected_data_length","isLongHeader","SHORT_MAX_LENGTH","totalLength","LONG_HEADER_SIZE","SHORT_HEADER_SIZE","Uint8ClampedArray","f","setFlag","length","getFlags","flags","at","more","FLAG_MORE","long","FLAG_LONG","key","value","oldFlags","validateLength","byteLength","headerSize","view","DataView","byteOffset","getUint32","getUint16","len","setInt32","setInt16","data","subarray","dataView","expected_length","Math","min","headerLength","fromArray","array","set","fromString","s","result","encoder","TextEncoder","encode","toString","decoder","TextDecoder","decode","fromUInt","int","Uint8Array","setUint32","toUInt","isUInt","fromBigUInt","setBigUint64","toBigUInt","getBigUint64","isBigUInt","pack","frames","map","v","reduce","prev","curr","bundle","offest","readHeader","lengthSize","lengthView","flagsObject","unpack","rest","headerResult","push","paddingLength","clone","padding","slice","LONG_MAX_LENGTH","toArrayBuffer","arrayBuffer","Promise","resolve","WebRTCDatachannel","rtcDataChan","bus","EventBus","onRemoteData","ev","addEventListener","emit","removeEventListener","send","message","dstUserDeviceId","roomId","srcUserDeviceId","dstId","srcId","payload","close","PROTO_TYPE_SYNC_PEERS","PROTO_TYPE_RTC_PROVIDE_OFFER","PROTO_TYPE_SYNC_PEERS_REP","PROTO_TYPE_RTC_ICE_CANDIDATE","PROTO_TYPE_MAX_NUM","DATACHANNEL_LABEL","DATACHANNEL_ID","RTCPEERCONNECTION_OPTIONS","iceServers","urls","PeerConnectionState","Peer","userDeviceId","clk","connection","RTCPeerConnection","datachannel","createDataChannel","protocol","id","negotiated","connectionState","makingOffer","setupConnectionState","undefined","iceConnectionState","restartIce","state","isConnectionAvaliable","disconnect","Router","alterChan","peers","BigInt","onMessageCallback","msg","broadcastId","handleProtocolMessage","onNegotiate","peer","setLocalDescription","then","offer","localDescription","sdp","type","provideRTCOffer","finally","onIceCandidate","candidate","sendRTCIceCandidate","on","broadcast","noAlternativeChannel","sendingPromises","sendToAlternativeChannel","all","findPeerById","loopbackSend","broadcastPeerList","customPeerIdList","isReply","peerIdList","p","buildProtocolMessage","addPeer","removePeer","index","indexOf","splice","detach","onSyncPeerMessage","code","receivedPeerList","JSON","parse","remotePeerList","Array","isArray","filter","uuidValidate","forEach","waitingTime","random","promiseTimeout","remoteUnknownPeerIds","includes","msgTypeCode","clkUpdate","catch","reason","console","error","onProvideRTCOfferMessage","onRTCIceCandidateMessage","tick","msgType","obj","stringify","stop","closePromise","i","pop","detachAll","dstUserDevId","offerTyped","setRemoteDescription","description","dstUsrDevId","toJSON","candidateTyped","remoteDescription","addIceCandidate","split","Error","size","str","byte_nbr","characterCode","divisor","idx","floor","dest","string_len","char_nbr","charCodeAt","SupabaseDatachannel","rtDbChannel","rtDbBroadcastChan","supabase","onRemoteMessage","onClose","onAnyChannelClose","isJoined","isJoining","subscribe","ofRoom","myUserDeviceId","rtChan","channel","selfBroadcast","rtBroadcast","from","insert","room","dst_user_dev_id","src_user_dev_id","z85","isClosed","errors","allFramesDecodedMark","record","decodedBuf","unsubscribe"],"mappings":"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"}